package ru.kpfu.itis.service;

import ru.kpfu.itis.model.GameMap;
import ru.kpfu.itis.model.Hex;
import ru.kpfu.itis.enums.Type;

import java.util.*;

public class MapFactory {

    public static GameMap createPeninsulaMap() {
        GameMap map = new GameMap(20, 19);
        int[][] peninsula = new int[][]{
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };
        placeHexesFromMap(map, peninsula);
        return map;
    }

    public static GameMap createSShapedMap() {
        GameMap map = new GameMap(20, 19);
        int[][] sShaped = new int[][]{
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };
        placeHexesFromMap(map, sShaped);
        return map;
    }

    public static GameMap createStarShapedMap() {
        GameMap map = new GameMap(20, 19);
        int[][] star = new int[][]{
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };
        placeHexesFromMap(map, star);
        return map;
    }

    public static GameMap createTShapedMap() {
        GameMap map = new GameMap(20, 19);
        int[][] tShaped = new int[][]{
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };
        placeHexesFromMap(map, tShaped);
        return map;
    }

    public static GameMap createCShapedMap() {
        GameMap map = new GameMap(20, 19);
        int[][] cShaped = new int[][]{
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        };
        placeHexesFromMap(map, cShaped);
        return map;
    }

    private static void placeHexesFromMap(GameMap map, int[][] pattern) {
        for (int y = 0; y < pattern.length && y < map.getHeight(); y++) {
            for (int x = 0; x < pattern[y].length && x < map.getWidth(); x++) {
                if (pattern[y][x] == 1) {
                    Hex hex = new Hex(x, y, Type.GRASS);
                    map.getGrid().get(y).set(x, hex);
                } else {
                    map.getGrid().get(y).set(x, null);
                }
            }
        }
    }

    private static void setStartingZones(GameMap map, int[][] player0Positions, int[][] player1Positions, 
                                         int[][] player2Positions, int[][] player3Positions) {
        setStartingZones(map, player0Positions, player1Positions, player2Positions, player3Positions, System.currentTimeMillis());
    }
    
    private static void setStartingZones(GameMap map, int[][] player0Positions, int[][] player1Positions, 
                                         int[][] player2Positions, int[][] player3Positions, long seed) {

        List<int[]> capitals = findOptimalCapitalPositions(map, 4, seed);
        
        for (int i = 0; i < capitals.size() && i < 4; i++) {
            int[] pos = capitals.get(i);
            Hex capital = map.getHex(pos[0], pos[1]);
            if (capital != null) {
                capital.setOwnerId(i);
                capital.setCapital(true);
            }
        }
        

        for (int i = 0; i < capitals.size() && i < 4; i++) {
            int[] pos = capitals.get(i);
            expandTerritory(map, pos[0], pos[1], i, 5);
        }
    }

    private static List<int[]> findOptimalCapitalPositions(GameMap map, int numCapitals, long seed) {
        List<int[]> landHexes = new ArrayList<>();
        for (int y = 0; y < map.getHeight(); y++) {
            for (int x = 0; x < map.getWidth(); x++) {
                Hex hex = map.getHex(x, y);
                if (hex != null && map.getGrid().get(y).get(x) != null) {
                    landHexes.add(new int[]{x, y});
                }
            }
        }
        
        if (landHexes.isEmpty()) {
            return new ArrayList<>();
        }
        
        landHexes.sort((a, b) -> {
            if (a[1] != b[1]) return Integer.compare(a[1], b[1]);
            return Integer.compare(a[0], b[0]);
        });
        
        List<int[]> capitals = new ArrayList<>();
        
        Random random = new Random(seed);
        int firstIndex = random.nextInt(landHexes.size());
        capitals.add(landHexes.get(firstIndex));
        
        for (int i = 1; i < numCapitals; i++) {
            int[] bestPos = null;
            double maxMinDistance = -1;
            
            for (int[] candidate : landHexes) {
                boolean alreadyChosen = false;
                for (int[] existing : capitals) {
                    if (existing[0] == candidate[0] && existing[1] == candidate[1]) {
                        alreadyChosen = true;
                        break;
                    }
                }
                if (alreadyChosen) continue;
                
                double minDistance = Double.MAX_VALUE;
                for (int[] existing : capitals) {
                    double dist = hexDistance(candidate[0], candidate[1], existing[0], existing[1]);
                    minDistance = Math.min(minDistance, dist);
                }
                
                if (minDistance > maxMinDistance) {
                    maxMinDistance = minDistance;
                    bestPos = candidate;
                }
            }
            
            if (bestPos != null) {
                capitals.add(bestPos);
            } else {
                List<int[]> available = new ArrayList<>();
                for (int[] hex : landHexes) {
                    boolean isChosen = false;
                    for (int[] cap : capitals) {
                        if (hex[0] == cap[0] && hex[1] == cap[1]) {
                            isChosen = true;
                            break;
                        }
                    }
                    if (!isChosen) {
                        available.add(hex);
                    }
                }
                if (!available.isEmpty()) {
                    capitals.add(available.get(random.nextInt(available.size())));
                }
            }
        }
        
        return capitals;
    }

    private static double hexDistance(int x1, int y1, int x2, int y2) {

        int q1 = x1;
        int r1 = y1 - (x1 - (x1 & 1)) / 2;
        int q2 = x2;
        int r2 = y2 - (x2 - (x2 & 1)) / 2;
        
        int s1 = -q1 - r1;
        int s2 = -q2 - r2;
        
        return (Math.abs(q1 - q2) + Math.abs(r1 - r2) + Math.abs(s1 - s2)) / 2.0;
    }

    private static void expandTerritory(GameMap map, int startX, int startY, int ownerId, int size) {
        Hex startHex = map.getHex(startX, startY);
        if (startHex == null) return;
        
        Set<String> claimed = new HashSet<>();
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{startX, startY});
        claimed.add(startX + "," + startY);
        
        int[][] directions = new int[][]{
            {1, 0}, {1, -1}, {0, -1}, {-1, 0}, {-1, 1}, {0, 1}  // для четных строк
        };
        int[][] directionsOdd = new int[][]{
            {1, 0}, {1, 1}, {0, -1}, {-1, 0}, {-1, 1}, {0, 1}  // для нечетных строк
        };
        
        int claimedCount = 1;
        
        while (!queue.isEmpty() && claimedCount < size) {
            int[] current = queue.poll();
            int cx = current[0];
            int cy = current[1];
            
            int[][] dirs = (cy % 2 == 0) ? directions : directionsOdd;
            
            List<int[]> neighbors = new ArrayList<>();
            for (int[] dir : dirs) {
                int nx = cx + dir[0];
                int ny = cy + dir[1];
                String key = nx + "," + ny;
                
                if (!claimed.contains(key)) {
                    Hex neighbor = map.getHex(nx, ny);
                    if (neighbor != null && neighbor.getOwnerId() == -1) {
                        if (nx >= 0 && nx < map.getWidth() && ny >= 0 && ny < map.getHeight()) {
                            Hex gridHex = map.getGrid().get(ny).get(nx);
                            if (gridHex != null) {
                                neighbors.add(new int[]{nx, ny});
                            }
                        }
                    }
                }
            }
            
            neighbors.sort((a, b) -> {
                int distA = Math.abs(a[0] - startX) + Math.abs(a[1] - startY);
                int distB = Math.abs(b[0] - startX) + Math.abs(b[1] - startY);
                return Integer.compare(distA, distB);
            });
            
            for (int[] neighbor : neighbors) {
                if (claimedCount >= size) break;
                
                String key = neighbor[0] + "," + neighbor[1];
                if (!claimed.contains(key)) {
                    Hex hex = map.getHex(neighbor[0], neighbor[1]);
                    if (hex != null && hex.getOwnerId() == -1) {
                        hex.setOwnerId(ownerId);
                        claimed.add(key);
                        queue.offer(neighbor);
                        claimedCount++;
                    }
                }
            }
        }
    }

    public static GameMap getMapById(int mapId) {
        return getMapById(mapId, System.currentTimeMillis());
    }
    
    public static GameMap getMapById(int mapId, long seed) {
        GameMap map = switch (mapId) {
            case 0 -> createPeninsulaMap();
            case 1 -> createSShapedMap();
            case 2 -> createStarShapedMap();
            case 3 -> createTShapedMap();
            case 4 -> createCShapedMap();
            default -> createPeninsulaMap();
        };
        setStartingZones(map, null, null, null, null, seed);
        return map;
    }

}
